(()=>{const P=RushGo.Win,v=window.RushGo.State,V=window.RushGo.HalfLine,H=window.RushGo.SingleLine,U=window.RushGo.CrossPoint,B=window.RushGo.ValueField;class p extends RushGo.AIThree{myMoves=[];otherMovers=[];expPower=.5;fExpCache;lExpCache;mCache;eCache;constructor(u,W,c,o,g,a,h,r,n,x){super(u,W,c,o,g,a,h,r,n,x)}combineStrategy(u,W){var c=[],o=[],g=new B;for(let h=0;h<=window.RushGo.Grid;h++){let r=[];for(let n=0;n<=window.RushGo.Grid;n++){let x=u[h][n],w=W[h][n],l=new v,f=[h,n],C=h+"-"+n;if(!x||!w)l.state=v.Alone;else if(x.state.state===v.Forbidden)g.state=v.Alone;else if(x.state.state===v.MustWin)g.mustWins.push(f),l.state=v.MustWin;else if(w.state.state===v.MustWin)g.mustLoses.push(f),l.state=v.MustLose;else if(x.state.state===v.WillWin)g.willWins.push(f),l.state=v.WillWin;else if(w.state.state===v.WillWin)g.willLoses.push(f),l.state=v.WillLose;else if(x.state.state===v.MayWin)g.mayWins.push(f),l.state=v.MayWin;else if(w.state.state===v.MayWin)g.mayLoses.push(f),l.state=v.MayLose;else if(x.state.state<=v.Alone)if(w.state.state<=v.Alone)l.state=v.Alone;else{g.normals.push(f),l.state=v.Normal;let G=this.eCache.get(w.toString())||0;l.score=(w.state.score+G*this.expPower)*(1-this.attacktive),l.score<0&&(l.score=0),o.push([f,l.score])}else{if(g.normals.push(f),l.state=v.Normal,w.state.state<=v.Alone){let G=this.mCache.get(x.toString())||0;l.score=(x.state.score+G*this.expPower)*this.attacktive}else{let G=this.mCache.get(x.toString())||0,e=this.eCache.get(w.toString())||0;l.score=(x.state.score+G*this.expPower)*this.attacktive+(w.state.score+e*this.expPower)*(1-this.attacktive)}l.score<0&&(l.score=0),o.push([f,l.score])}l.update(),r[n]=[l,x?x.toString():null,w?w.toString():null]}c[h]=r}o=o.filter(h=>h[1]>0),o.sort((h,r)=>r[1]-h[1]);var a=0;return o.forEach(h=>a+=h[1]),o.forEach(h=>h[1]/=a),[o,c,g]}makeDecision(u,W,c,o,g,a,h,r){window.RushGo.DrawStrategy&&(console.log("====> Make Decision <==== ["+(window.RushGo.loopCount+1)+"]    "+this.id+"("+this.level+")"),r.mustWins.length>0&&console.log("    MustWins : ("+r.mustWins.join("), (")+")"),r.mustLoses.length>0&&console.log("    MustLoses: ("+r.mustLoses.join("), (")+")"),r.willWins.length>0&&console.log("    WillWins : ("+r.willWins.join("), (")+")"),r.willLoses.length>0&&console.log("    WillLoses: ("+r.willLoses.join("), (")+")"),r.mayWins.length>0&&console.log("    MayWins  : ("+r.mayWins.join("), (")+")"),r.mayLoses.length>0&&console.log("    MayLoses : ("+r.mayLoses.join("), (")+")"));var n=[],x=[];if(r.mustWins.length>0?n=r.mustWins.map(e=>{var t=h[e[0]];return t=t[e[1]],t?(t=(this.mCache.get(t[1])||0)*this.attacktive+(this.eCache.get(t[2])||0)*(1-this.attacktive),t<-.999&&(t=-.999),[e,1+t]):[e,1]}):r.mustLoses.length>0?n=r.mustLoses.map(e=>{var t=h[e[0]];return t=t[e[1]],t?(t=(this.mCache.get(t[1])||0)*this.attacktive+(this.eCache.get(t[2])||0)*(1-this.attacktive),t<-.999&&(t=-.999),[e,1+t]):[e,1]}):r.willWins.length>0?n=r.willWins.map(e=>{var t=h[e[0]];return t=t[e[1]],t?(t=(this.mCache.get(t[1])||0)*this.attacktive+(this.eCache.get(t[2])||0)*(1-this.attacktive),t<-.999&&(t=-.999),[e,1+t]):[e,1]}):r.willLoses.length>0?n=r.willLoses.map(e=>{var t=h[e[0]];return t=t[e[1]],t?(t=(this.mCache.get(t[1])||0)*this.attacktive+(this.eCache.get(t[2])||0)*(1-this.attacktive),t<-.999&&(t=-.999),[e,1+t]):[e,1]}):r.mayWins.length>0?n=r.mayWins.map(e=>{var t=h[e[0]];return t=t[e[1]],t?(t=(this.mCache.get(t[1])||0)*this.attacktive+(this.eCache.get(t[2])||0)*(1-this.attacktive),t<-.999&&(t=-.999),[e,1+t]):[e,1]}):r.mayLoses.length>0&&(n=r.mayLoses.map(e=>{var t=h[e[0]];return t=t[e[1]],t?(t=(this.mCache.get(t[1])||0)*this.attacktive+(this.eCache.get(t[2])||0)*(1-this.attacktive),t<-.999&&(t=-.999),[e,1+t]):[e,1]})),n.length===1)return[n[0][0],[]];if(n.length>0){let e=0;n.forEach(t=>e+=t[1]),a=n.map(t=>[t[0],t[1]/e])}else if(a.length>this.range){let e=a[this.range-1][1],t=a.filter(m=>m[1]>e),d=a.filter(m=>m[1]===e);e=this.range-t.length;for(let m=0;m<e;m++){let E=d.length;E=Math.floor(E*Math.random()),E=d.splice(E,1)[0],t.push(E)}a=t}n=[];var w=[];if(W+=c.scoreW/P,o+=g.scoreW/P,window.RushGo.DrawStrategy&&console.log("    Branch Count: "+a.length),a.forEach(e=>{var[t,d]=e,m=this.goDeep(u,...t);if(!m&&window.RushGo.DrawStrategy&&console.log("    .... ("+t+") "+d+" >> null"),!!m){if(m[0]===-1){let R=m[1]-W,i=o-m[2],s=R*this.attacktive+i*(1-this.attacktive);s=(P+s/P)/P,e[1]*=s,window.RushGo.DrawStrategy&&console.log("    .... ("+t+") "+d+" >> null ("+s+")");return}var E={};m.forEach(R=>{var[i,s,S,k,y]=R,M=E[i];M||(M=[0,0,0,!1],E[i]=M),y===M[3]?(M[0]+=s*d,M[1]+=S*d):y&&!M[3]&&(M[0]+=s*d*this.decayRate,M[1]+=S*d*this.decayRate),k>M[2]&&(M[2]=k),M[3]=M[3]||y});var D=0;for(let R in E){let[i,s,S,k]=E[R];R*=1;let y=0;R===this.id?y=i*this.attacktive-s*(1-this.attacktive):y-=i*(1-this.attacktive)-s*this.attacktive,D+=y,window.RushGo.DrawStrategy&&console.log("    :::: ("+t+") "+d+" : "+R+" >> "+i+" / "+s+" ("+S+") >> "+y+"    M: "+k)}if(D>0){let R=!0,i=-1;w.some((s,S)=>{if(s[0]!==t)return!1;s[1]+D<1?R=!1:i=S}),R?n.push([t,D]):i>=0&&w.splice(i,1)}else if(D<0){let R=!0,i=-1;n.some((s,S)=>{if(s[0]!==t)return!1;s[1]+D>0?R=!1:i=S}),R?w.push([t,1+D]):i>=0&&n.splice(i,1)}}}),n.length>0){let e=0;n.forEach(t=>e+=t[1]),n.forEach(t=>t[1]/=e),a=n}if(w.length>0){let e=[];a.forEach(t=>{var d=!1;w.some(m=>t[0]!==m[0]?!1:(d=!0,t[1]=m[1],!0)),d?window.RushGo.DrawStrategy&&console.log("  REMOVE ~~> ("+t[0]+") : "+t[1]):e.push(t)}),e.length>0?a=e:window.RushGo.DrawStrategy&&console.log("  >>>> No Choise Available Now!!! <<<<")}if(a.length===0)return[null,[]];if(a.sort((e,t)=>t[1]-e[1]),a.length>this.range){let e=a[this.range][1],t=a.filter(d=>d[1]>e);if(t.length<this.range){let d=a.filter(m=>m[1]===e);e=this.range-t.length;for(let m=0;m<e;m++){let E=d.length;E=Math.floor(E*Math.random()),E=d.splice(E,1)[0],t.push(E)}}a=t}var l=0;a.forEach(e=>l+=e[1]),l===0?(l=a.length,a.forEach(e=>{e[1]=1/l,x.push([...e,0]),window.RushGo.DrawStrategy&&console.log("  --> ("+e[0]+") : "+e[1])})):a.forEach(e=>{e[1]/=l,x.push([...e,0]),window.RushGo.DrawStrategy&&console.log("  --> ("+e[0]+") : "+e[1])});var f=0,C=a[0][1];a.forEach(e=>{e[1]>f&&(f=e[1]),e[1]<C&&(C=e[1])}),f===C?(f=a.length,a.forEach((e,t)=>e[1]=(t+1)/f)):(C=f-(f-C)*.1,a=a.filter(e=>e[1]>=C),f=0,a.forEach(e=>{e[1]-=C,e[1]=e[1]**window.RushGo.ScorePower,f+=e[1]}),C=0,a.forEach(e=>{e[1]/=f,C+=e[1],e[1]=C})),C=Math.random();var G=null;return a.some((e,t)=>(G=e[0],C>=e[1])),[G,x]}goDeep(u,W,c,o=this.id,g=this.level){if(g<=0)return null;u=window.RushGo.copyRushGo(u),u[W][c]=o;var a=window.RushGo.checkFinish(u,o,W,c);if(a>0)return[[o,1,0,1,!0]];if(a<0)return[[o,0,1,1,!0]];var h=o+1;h===2&&(h=0);var r=window.RushGo.analyzeRush(u,h,!1,this.rangeMind),n=[];for(let i=0;i<2;i++)i!==h&&n.push(window.RushGo.analyzeRush(u,i,!0,this.rangeMind));n=window.RushGo.combineEnemy(n);var[x,w]=window.RushGo.valueStatus(r),[l,f]=window.RushGo.valueStatus(n),[C,G,e]=this.combineStrategy(r,n),t=[];w.mustWins.length>0?t=w.mustWins.map(i=>{var s=G[i[0]];return s=s[i[1]],s?(s=(this.mCache.get(s[1])||0)*this.attacktive+(this.eCache.get(s[2])||0)*(1-this.attacktive),s<-.999&&(s=-.999),[i,1+s]):[i,1]}):f.mustWins.length>0?t=f.mustWins.map(i=>{var s=G[i[0]];return s=s[i[1]],s?(s=(this.mCache.get(s[1])||0)*this.attacktive+(this.eCache.get(s[2])||0)*(1-this.attacktive),s<-.999&&(s=-.999),[i,1+s]):[i,1]}):w.willWins.length>0?t=w.willWins.map(i=>{var s=G[i[0]];return s=s[i[1]],s?(s=(this.mCache.get(s[1])||0)*this.attacktive+(this.eCache.get(s[2])||0)*(1-this.attacktive),s<-.999&&(s=-.999),[i,1+s]):[i,1]}):f.willWins.length>0?t=f.willWins.map(i=>{var s=G[i[0]];return s=s[i[1]],s?(s=(this.mCache.get(s[1])||0)*this.attacktive+(this.eCache.get(s[2])||0)*(1-this.attacktive),s<-.999&&(s=-.999),[i,1+s]):[i,1]}):w.mayWins.length>0?t=w.mayWins.map(i=>{var s=G[i[0]];return s=s[i[1]],s?(s=(this.mCache.get(s[1])||0)*this.attacktive+(this.eCache.get(s[2])||0)*(1-this.attacktive),s<-.999&&(s=-.999),[i,1+s]):[i,1]}):f.mayWins.length>0&&(t=f.mayWins.map(i=>{var s=G[i[0]];return s=s[i[1]],s?(s=(this.mCache.get(s[1])||0)*this.attacktive+(this.eCache.get(s[2])||0)*(1-this.attacktive),s<-.999&&(s=-.999),[i,1+s]):[i,1]}));var d=!0,m=0;if(t.length===0){if(d=!1,C.length===0)return[-1,x+w.scoreW/P,l+f.scoreW/P];let i=Math.ceil(this.deepRange*(g/this.level)**this.decayPower);if(C.forEach(s=>m+=s[1]),C.length>i){let s=C[i-1][1];t=C.filter(k=>k[1]>s);let S=C.filter(k=>k[1]===s);s=i-t.length;for(let k=0;k<s;k++){let y=S.length;y=Math.floor(y*Math.random()),y=S.splice(y,1)[0],t.push(y)}}}else t.forEach(i=>m+=i[1]);var E={};d||g--;var D=!1;if(t.forEach(i=>{var[s,S]=i;S/=m;var k=this.goDeep(u,...s,h,g);!k||k[0]===-1||(D=!0,k.forEach(y=>{var[M,N,O,j,z]=y,L=E[M];L||(L=[0,0,0,!1],E[M]=L),z?(L[0]+=N*S,L[1]+=O*S):(L[0]+=N*S*this.decayRate,L[1]+=O*S*this.decayRate),j++,j>L[2]&&(L[2]=j),L[3]=L[3]||z&&d}))}),!D)return[-1,x+w.scoreW/P,l+f.scoreW/P];var R=[];for(let i in E)R.push([i*1,...E[i]]);return R}recordMe(u){this.myMoves.push(u)}recordOther(u){this.otherMovers.push(u)}async loadMap(){var u=window.RushGo.GameModeOption.getDBName();[this.fExpCache,this.lExpCache]=await Promise.all([p.loadExp(u+"f"),p.loadExp(u+"l")]),this.id===window.RushGo.starter?(this.mCache=this.fExpCache,this.eCache=this.lExpCache):(this.mCache=this.lExpCache,this.eCache=this.fExpCache)}async flush(u){u?(this.myMoves.forEach((c,o)=>{var g=o/(window.RushGo.loopCount+o)*p.LearningRate,a=this.mCache.get(c)||0;a+=g,this.mCache.set(c,a)}),this.otherMovers.forEach((c,o)=>{var g=o/(window.RushGo.loopCount+o)*p.LearningRate,a=this.eCache.get(c)||0;a-=g/2,this.eCache.set(c,a)})):(this.otherMovers.forEach((c,o)=>{var g=o/(window.RushGo.loopCount+o)*p.LearningRate,a=this.eCache.get(c)||0;a+=g,this.eCache.set(c,a)}),this.myMoves.forEach((c,o)=>{var g=o/(window.RushGo.loopCount+o)*p.LearningRate,a=this.mCache.get(c)||0;a-=g/2,this.mCache.set(c,a)}));var W=window.RushGo.GameModeOption.getDBName();await Promise.all([p.updateExp(W+"f",this.fExpCache),p.updateExp(W+"l",this.lExpCache)]),this.clear()}clear(){this.myMoves.splice(0,this.myMoves.length),this.otherMovers.splice(0,this.otherMovers.length)}static LearningRate=.001;static ExpStorage;static async initExpStorage(){p.ExpStorage=new CachedDB("AI4Exp",1),p.ExpStorage.onUpdate(()=>{p.ExpStorage.open("n0f","dist"),p.ExpStorage.open("n3f","dist"),p.ExpStorage.open("n5f","dist"),p.ExpStorage.open("f0f","dist"),p.ExpStorage.open("f3f","dist"),p.ExpStorage.open("f5f","dist"),p.ExpStorage.open("n0l","dist"),p.ExpStorage.open("n3l","dist"),p.ExpStorage.open("n5l","dist"),p.ExpStorage.open("f0l","dist"),p.ExpStorage.open("f3l","dist"),p.ExpStorage.open("f5l","dist"),console.log("AI4::ExpStorage Updated")}),p.ExpStorage.onConnect(()=>{console.log("AI4::ExpStorage Connected")}),await p.ExpStorage.connect()}static async loadExp(u){var W=new Map,c=await p.ExpStorage.all(u);for(let o in c){let g=c[o];W.set(o,g)}return console.log("Experience Count: "+W.size+" ("+u+")"),W}static async updateExp(u,W){var c=[];for(let o of W)c.push(o);await Promise.all(c.map(o=>p.ExpStorage.set(u,o[0],o[1]))),console.log("Experience Count: "+W.size+" ("+u+")")}}window.RushGo=window.RushGo||{},window.RushGo.AIFour=p})();
